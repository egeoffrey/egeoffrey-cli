#!/usr/bin/python

import sys
import os
import re
import time
import json
import yaml
import subprocess
import requests
import filecmp

## constants
BRANCH = "development"
VERSION = 1.0
REVISION = 20
MARKETPLACE_URL = "https://api.github.com/repos/egeoffrey/egeoffrey-marketplace/contents/marketplace"
MARKETPLACE_BRANCH = "master"
SDK_BRANCH = "development"
MY_MANIFEST_URL = "https://raw.githubusercontent.com/egeoffrey/egeoffrey-cli/"+BRANCH+"/version.yml"
MY_DOWNLOAD_URL = "https://raw.githubusercontent.com/egeoffrey/egeoffrey-cli/"+BRANCH+"/egeoffrey-cli"
MY_DIRECTORY = os.getcwd()
DOCKER_COMPOSE = "docker-compose.yml"
SUPPORTED_MANIFEST_SCHEMA = 2

## variables
# debug output 
DEBUG = False
# do not require user interaction
QUITE = False
# do not push anything out
OFFLINE = False
# requested command
COMMAND = ""
# arguments to the requested command
ARGUMENTS = ""
# docker-compose .env 
ENV = {}
# docker-compose configuration
CONFIG = {}

# print out an error message and exit
def print_error(message):
    print "\033[91mERROR\033[0m: "+str(message)
    exit(1)
    
# print out a warning message
def print_warning(message):
    print "\033[33mWARNING\033[0m: "+str(message)
    
# print out a debug message
def print_debug(message):
    global DEBUG
    if DEBUG: print message

# print out a message    
def print_output(message):
    print message
    
# parse command line arguments
def parse_command_line():
    global COMMAND, ARGUMENTS, DEBUG, QUITE, OFFLINE, MY_DIRECTORY, DOCKER_COMPOSE
    skip_next = False
    for i in range(1, len(sys.argv)):
        if skip_next: 
            skip_next = False
            continue
        arg = sys.argv[i]
        arg = re.sub(' +',' ', arg)
        if arg == "-d":
            MY_DIRECTORY = sys.argv[i+1].rstrip("/")
            skip_next = True
            continue
        if arg == "-f":
            DOCKER_COMPOSE = sys.argv[i+1]
            skip_next = True
            continue
        if arg == "-v":
            DEBUG = True
            continue
        if arg == "-o":
            OFFLINE = True
            continue
        if arg == "-q":
            QUITE = True
            continue
        if COMMAND == "":
            COMMAND = arg
            continue
        ARGUMENTS = ARGUMENTS+" "+arg
    ARGUMENTS = ARGUMENTS.strip()
    print_debug("Base directory: "+MY_DIRECTORY)
    print_debug("Command: "+COMMAND)
    print_debug("Arguments: "+ARGUMENTS)
    
# check if the cli requires to be upgraded
def requires_upgrade():
    # download the manifest from github which contains the latest version number
    print_debug("Downloading egeoffrey-cli manifest from "+MY_MANIFEST_URL)
    try:
        response = requests.get(MY_MANIFEST_URL+"?timestamp="+str(int(time.time())))
        if response.status_code != 200: print_error("Unable to download egeoffrey-cli manifest")
        manifest =  yaml.load(response.content, Loader=yaml.SafeLoader)
    except Exception,e:
        print_error("Unable to download egeoffrey-cli manifest: "+str(e))
    # check if we are at the latest version
    print_debug("egeoffrey-cli latest release v"+str(manifest["revision"])+", currently running v"+str(REVISION))
    if manifest["version"] > VERSION or (manifest["version"] == VERSION and manifest["revision"] > REVISION): return str(manifest["version"])+"-"+str(manifest["revision"])
    return None
    
# load .env file with common docker-compose environment variables
def load_env():
    global ENV
    env_file = MY_DIRECTORY+"/.env"
    if not os.path.isfile(env_file):
        print_error("the configuration file '.env' cannot be found in "+env_file+". Please switch into eGeoffrey installation directory or provide the directory with the -d option")
    try:
        with open(env_file) as f: content = f.read()
        for line in content.split("\n"):
            # clean up the file
            line = re.sub(' +',' ', line).replace('"', "")
            if line.startswith("#"): continue
            if "=" not in line: continue
            split = line.split("=")
            # store it into the env variable
            ENV[split[0]] = split[1]
    except Exception,e: 
        print_error("unable to read environment file from "+env_file+": "+str(e))
    print_debug("Loaded "+str(len(ENV))+" env settings")

# download and return a manifest from a remote git repository
def get_manifest(package, repository, branch):
    print_debug("Loading manifest file for package "+package+":"+branch)
    try:
        manifest_url = "https://raw.githubusercontent.com/"+repository+"/"+branch+"/manifest.yml?timestamp="+str(int(time.time()))
        response = requests.get(manifest_url)
        if response.status_code != 200: 
            print_warning("skipping package "+package+":"+branch)
            return None
        return yaml.load(response.content, Loader=yaml.SafeLoader)
    except Exception,e:
        print_warning("skipping package "+package+":"+branch+": "+str(e))
        return None    

# return an array of registered packages in the marketplace
def list_marketplace():
    index = []
    print_debug("Listing Marketplace items...")
    try:
        # list all files in the marketplace database
        response = requests.get(MARKETPLACE_URL+"?ref="+MARKETPLACE_BRANCH)
        if response.status_code != 200: print_error("Unable to list marketplace items")
        content = json.loads(response.content)
        # for each package in the marketplace
        for entry in content:
            if "path" not in entry or "name" not in entry: continue
            index.append(entry["name"].replace(".yml", ""))
        print_debug("Marketplace has "+str(len(content))+" entries")
        return index
    except Exception,e:
        print_error("Unable to list marketplace items: "+str(e))

# return the github repo of a marketplace package 
def get_repository(package):
    try: 
        # download from the marketplace the file for the package
        response = requests.get("https://raw.githubusercontent.com/egeoffrey/egeoffrey-marketplace/"+MARKETPLACE_BRANCH+"/marketplace/"+package+".yml?timestamp="+str(int(time.time())))
        if response.status_code != 200: print_error("Unable to retrieve github repository for package "+package)
        content = yaml.load(response.content, Loader=yaml.SafeLoader)
        if "github" not in content: return None
        return content["github"]
    except Exception,e:
        print_error("Unable to retrieve github repository for package "+package+": "+str(e))
        
# parse a package splitting the package name from the branch
def parse_package(string):
    package = string
    branch = "master"
    if ":" in string: package, branch = string.split(":", 1)
    return package, branch        
    
# build the marketplace database
def get_marketplace(requested_packages=None, package_branch="master"):
    global ENV
    marketplace = {}
    # get the list of all items in the marketplace
    marketplace_index = list_marketplace()
    try:
        # for each package in the marketplace
        for i in range(0, len(marketplace_index)):
            marketplace_package = marketplace_index[i]
            # no specific package requested, tell the user we need to download the entire marketplace
            if requested_packages is None:
                msg = "Downloading marketplace database: "+str( (i+1)*100/len(marketplace_index) )+"%"
                sys.stdout.write('\r')
                sys.stdout.write(msg)
                sys.stdout.flush()
                if i == len(marketplace_index)-1: sys.stdout.write('\n')
            # if specific packages are requested, filter out unwanted packages
            if requested_packages is not None:
                include_package = False
                for package in requested_packages:
                    package_name, package_branch = parse_package(package)
                    if package_name == marketplace_package: include_package = True
                if not include_package: continue
            # download the marketplace item which contains the github repo reference
            repository = get_repository(marketplace_package)
            if repository is None: continue
            # download the manifest from the remote repository
            manifest = get_manifest(marketplace_package, repository, package_branch)
            if manifest is None: continue
            if manifest["manifest_schema"] != SUPPORTED_MANIFEST_SCHEMA:
                print_warning("Skipping package "+marketplace_package+" because manifest v"+str(manifest["manifest_schema"])+" is not supported")
                continue
            # populate the marketplace
            marketplace[marketplace_package] = manifest
        return marketplace
    except Exception,e:
        print_error("Unable to build marketplace index: "+str(e))
        
# load docker-compose configuration
def load_configuration():
    global CONFIG
    docker_compose_file = MY_DIRECTORY+"/"+DOCKER_COMPOSE
    # load docker-compose common variables
    load_env()
    # if docker-compose file does not exist, make an empty version
    if not os.path.isfile(docker_compose_file): 
        CONFIG = {
            "version": "3",
            "services": {},
            "networks": {
                "egeoffrey": {
                    "driver": "bridge"
                }
            }
        }
    else:
        print_debug("Loading docker-compose configuration from "+docker_compose_file)
        try:
            with open(docker_compose_file) as f: content = f.read()
            CONFIG = yaml.load(content, Loader=yaml.SafeLoader)
        except Exception,e:
            print_error("Unable to load eGeoffrey docker configuration: "+str(e))
        
# save docker-compose configuration
def save_configuration():
    global CONFIG
    docker_compose_file = MY_DIRECTORY+"/"+DOCKER_COMPOSE
    print_debug("Saving docker-compose configuration to "+docker_compose_file)
    try: 
        f = open(docker_compose_file, "w")
        f.write(yaml.safe_dump(CONFIG, default_flow_style=False))
        f.close()
    except Exception,e:
        print_error("Unable to save eGeoffrey docker configuration: "+str(e))
       
# run a command    
def run(command):
    return subprocess.Popen(command, shell=True, stdout=subprocess.PIPE,  stderr=subprocess.PIPE).stdout.read()

# run docker-compose
def run_docker_compose(args):
    current_dir = os.getcwd()
    # when docker-compose runs in a container cannot mount the target directory, let's chdir into it first
    os.chdir(MY_DIRECTORY)
    docker_compose_file = MY_DIRECTORY+"/"+DOCKER_COMPOSE
    subprocess.call(["docker-compose", "-f", docker_compose_file] + args)
    # get back to the original directory
    os.chdir(current_dir)
    
# run docker
def run_docker(args):
    subprocess.call(["docker"] + args)

# run git
def run_git(args):
    return subprocess.check_output(["git", "-C", MY_DIRECTORY] + args)
    
# read and return a (local) manifest file
def read_manifest(manifest_file):
    if not os.path.isfile(manifest_file):
        print_error("Unable to find a manifest file in "+MY_DIRECTORY)
    try:
        with open(manifest_file) as f: content = f.read()
        manifest = yaml.load(content, Loader=yaml.SafeLoader)
    except Exception,e:
        print_error("Invalid manifest file in "+MY_DIRECTORY+": "+str(e))
    if manifest["manifest_schema"] != SUPPORTED_MANIFEST_SCHEMA:
        print_error("manifest v"+str(manifest["manifest_schema"])+" is not supported")
    return manifest
    
# print usage
def print_usage():
    print_output("egeoffrey-cli v"+str(VERSION)+"-"+str(REVISION)+" ("+str(BRANCH)+")")
    print_output("Usage: egeoffrey-cli [OPTIONS] COMMAND ARGUMENTS")
    print_output("")
    print_output("Options:")
    print_output("  -d <directory>                      set the working directory")
    print_output("  -f <filename>                       set custom docker-compose.yml filename")
    print_output("  -v                                  enable DEBUG output")
    print_output("  -q                                  quite mode - do not run interactively")
    print_output("  -o                                  offline mode")
    print_output("")
    print_output("General commands:")
    print_output("  upgrade                             Upgrade egeoffrey-cli to the latest version")
    print_output("  version                             Print out this script version")
    print_output("")
    print_output("Run commands:")
    print_output("  info <package>                      Print out information on a given package")
    print_output("  install <package(s)>                Install the provided package(s)")
    print_output("  list_available [<branch>]           List available packages that can be installed")
    print_output("  list_installed                      List already installed packages")
    print_output("  logs [-f] [<package(s)>]            Print out log information")
    print_output("  reload                              Reload the configuration")
    print_output("  search <string> [branch]            Search packages matching the provided description")
    print_output("  start [<package(s)>]                Start configured services")
    print_output("  stats                               Print out running packages CPU and memory utilization")
    print_output("  status                              Show currently running components")
    print_output("  stop                                Stop running services")
    print_output("  update [<package(s)>]               Update the installed package(s)")
    print_output("  uninstall [<package(s)>]            Uninstall the provided package(s)")
    print_output("")
    print_output("Build commands:")
    print_output("  commit '<description>'              Commit changes to the local and remote git repository")
    print_output("  build <amd64,arm>                   Build a docker image and push it upstream")
    print_output("  build_sdk <image> <amd64,arm>       Build a SDK docker image and push it upstream")
    print_output("  make_collection                     Create a collection including the configured packages")

        
## MAIN - RUN ##

# parse provided command line
parse_command_line()
# check if running the latest version
if not OFFLINE and COMMAND != "upgrade":
    version = requires_upgrade()
    if version is not None: print_warning("a new version of egeoffrey-cli is available ("+version+"), run 'egeoffrey-cli upgrade' to upgrade")

# do what requested by the user

# print out information on a given package
if COMMAND == "info":
    package = ARGUMENTS
    if package == "": print_error("a package name must be provided")
    marketplace = get_marketplace([package])
    package_name, package_branch = parse_package(package)
    if package_name not in marketplace: print_error("package "+package+" not found")
    manifest = marketplace[package_name]
    print_output("Package: "+manifest["package"])
    print_output("Tags: "+manifest["tags"])
    print_output("Version: "+str(manifest["version"])+"-"+str(manifest["revision"])+" ("+str(manifest["branch"])+")")
    print_output("Github: https://github.com/"+manifest["github"])
    print_output("Docker: "+manifest["dockerhub"])
    modules = []
    for module_object in manifest["modules"]:
        for module in module_object:
            modules.append(module)
    print_output("Modules: "+", ".join(modules))
    print_output("")
    print_output(manifest["description"])
    print_output("")
    
# install a package
elif COMMAND == "install":
    load_configuration()
    packages = ARGUMENTS.split(" ")
    if len(packages) == 0: print_error("at least a package name must be provided")
    marketplace = get_marketplace(packages)
    for package in packages:
        package_name, package_branch = parse_package(package)
        # ensure package is not already installed
        if package_name in CONFIG["services"]:
            print_output(package_name+" is already installed")
            continue
        # ensure package exists in the marketplace
        if package_name not in marketplace:
            print_output(package_name+" not found in the marketplace, skipping")
            continue
        # add the package to the docker-compose file
        try:
            service = {}
            manifest =  marketplace[package_name]
            print_debug("Installing package "+package_name+":"+package_branch)
            # if runtime parameters are provided, merge them with the service
            if "container_config" in manifest: 
                print_debug("Container default runtime: "+str(manifest["container_config"]))
                service.update(manifest["container_config"])
            # add env_file
            service["env_file"] = ".env"
            # add image
            service["image"] = manifest["dockerhub"]+":"+package_branch+"-"+ENV["ARCHITECTURE"]
            # add EGEOFFREY_MODULES variable
            if "modules" in manifest:
                modules = []
                for module_object in manifest["modules"]:
                    for module in module_object:
                        modules.append(module)
                if len(modules) > 0:
                    if "environment" not in service: service["environment"] = []
                    service["environment"].append("EGEOFFREY_MODULES="+", ".join(modules))
            # link to the default bridge network if no other instructions are provided
            if "network_mode" not in service and "networks" not in service:
                service["networks"] = []
                service["networks"].append("egeoffrey")
            # if there is a volume mapping, create the local MY_DIRECTORY
            if "volumes" in service:
                for volume in service["volumes"]:
                    volume = volume.replace('"', "")
                    split = volume.split(":")
                    directory = split[0]
                    if not os.path.exists(directory):
                        print_debug("Creating directory "+directory)
                        os.makedirs(directory)
            if "devices" in service:
                for device in service["devices"]:
                    device = device.replace('"', "")
                    split = device.split(":")
                    print_output("Please ensure the mapped device "+split[0]+" exists")
            # the docker daemon will restart the service at boot time
            # TODO: add restart = always
            #service["restart"] = "always"
            # add the new service
            CONFIG["services"][package_name] = service
        except Exception,e:
            print_error("installation of package "+package_name+":"+package_branch+" failed: "+str(e))
        print_output(package_name+":"+package_branch+" installed successfully")
    # save the updated configuration file
    save_configuration()
    
# list packages available to install
elif COMMAND == "list_available":
    load_configuration()
    branch = ARGUMENTS if ARGUMENTS != "" else "master"
    marketplace = get_marketplace(None, branch)
    for package in sorted(marketplace):
        # skip already installed packages
        if package in CONFIG["services"]: continue
        print_output(package+": "+marketplace[package]["description"])

# list packages already installed
elif COMMAND == "list_installed":
    load_configuration()
    for service in sorted(CONFIG["services"]):
        print_output(service)
        
# run docker logs
elif COMMAND == "logs":
    options = ARGUMENTS.split(" ") if ARGUMENTS != "" else []
    run_docker_compose(["logs"]+options)
    
# reload the configuration
elif COMMAND == "reload":
    run_docker_compose(["up", "-d", "--remove-orphans"])

# search for a package
elif COMMAND == "search":
    search = ARGUMENTS.split(" ")
    if len(search) == 0 or len(search) > 2: print_error("invalid search string provided")
    branch = "master"
    if len(search) == 2: branch = search[1]
    load_configuration()
    marketplace = get_marketplace(None, branch)
    words = search[0].split(" ")
    for package in sorted(marketplace):
        if len(list(set(words) & set(marketplace[package]["description"].split(" ")))) > 0 or len(list(set(words) & set(marketplace[package]["tags"].split(" ")))) > 0:
            print_output(package+": "+marketplace[package]["description"])
            
# start services
elif COMMAND == "start":
    packages = ARGUMENTS.split(" ") if ARGUMENTS != "" else []
    run_docker_compose(["up", "-d", "--remove-orphans"]+packages)
    
# run docker stats
elif COMMAND == "stats":
    run_docker(["stats", "--no-stream"])

# run docker ps
elif COMMAND == "status":
    run_docker_compose(["ps"])

# stop services
elif COMMAND == "stop":
    run_docker_compose(["down"])
    
# update an installed packages
elif COMMAND == "update":
    packages = ARGUMENTS.split(" ") if ARGUMENTS != "" else []
    run_docker_compose(["pull"]+packages)
    
# uninstall a package
elif COMMAND == "uninstall":
    load_configuration()
    packages = ARGUMENTS.split(" ")
    if len(packages) == 0: print_error("at least a package name must be provided")
    for package in packages:
        package_name, package_branch = parse_package(package)
        # ensure package is installed
        if package_name not in CONFIG["services"]:
            print_output(package_name+" is not installed")
            continue
        # remove the package from the docker-compose file
        del CONFIG["services"][package_name]
        print_output(package_name+" uninstalled successfully")
    # save the updated configuration file
    save_configuration()
    
## MAIN - BUILD ##

# commit changes to a git repository and push upstream
elif COMMAND == "commit":
    if ARGUMENTS == "": print_error("provide a description for this commit")
    # read the manifest file
    manifest_file = MY_DIRECTORY+"/manifest.yml"
    manifest = read_manifest(manifest_file)
    # ensure we are in the same branch of the manifest
    output = run_git(["branch"])
    branch = None
    for line in output.split("\n"):
        if line.startswith("* "): branch = line.replace("* ","")
    if branch is None: print_error("unable to determine current branch of "+MY_DIRECTORY)
    if branch != manifest["branch"]: print_error(MY_DIRECTORY+" current branch does not match with the manifest's branch")
    if "nothing to commit" not in run_git(["status"]):
        # ask the user before proceeding
        if not QUITE:
            # add the new files to git
            print_output(run_git(["add", "."]))
            print_output(run_git(["status"]))
            raw_input("Do you want to proceed committing these changes?")
        # increase revision number
        manifest["revision"] = manifest["revision"]+1
        # convert the manifest back to YAML
        try:
            content = yaml.safe_dump(manifest, default_flow_style=False)
        except Exception,e:
            print_error("unable to edit the manifest file: "+str(e))
        # save the updated manifest
        try:
            f = open(manifest_file, "w")
            f.write(content)
            f.close()
        except Exception,e:
            print_error("unable to write the manifest file: "+str(e))
        print_output("Setting new version for "+manifest["package"]+" to "+str(manifest["version"])+"-"+str(manifest["revision"])+" ("+str(manifest["branch"])+")")
        # generate a README.md file
        package_split = manifest["package"].split("-")
        readme = ""
        readme = readme+"# "+manifest["package"]+"\n\n"
        readme = readme+"This is an eGeoffrey "+package_split[1]+" package.\n"
        readme = readme+"\n## Description\n\n"
        readme = readme+manifest["description"]+".\n"
        readme = readme+"\n## Install\n\n"
        readme = readme+"To install this package, run the following command from within your eGeoffrey installation directory:\n"
        readme = readme+"```\negeoffrey-cli install "+manifest["package"]+"\n```\n"
        readme = readme+"After the installation, remember to run also `egeoffrey-cli start` to ensure the Docker image of the package is effectively downloaded and started.\n"
        readme = readme+"To validate the installation, go and visit the *'eGeoffrey Admin'* / *'Packages'* page of your eGeoffrey instance. All the modules, default configuration files and out-of-the-box contents if any will be automatically deployed and made available."
        if len(manifest["modules"]) > 0:
            readme = readme+"\n## Content\n\n"
            readme = readme+"The following modules are included in this package.\n\nFor each module, if requiring a configuration file to start, its settings will be listed under *'Module configuration'*. Additionally, if the module is a service, the configuration expected to be provided by each registered sensor associated to the service is listed under *'Service configuration'*.\n\nTo configure each module included in this package, once started, click on the *'Edit Configuration'* button on the *'eGeoffrey Admin'* / *'Modules'* page of your eGeoffrey instance.\n"
            for module_object in manifest["modules"]:
                for module_name in module_object:
                    module = module_object[module_name]
                    readme = readme+"- **"+module_name+"**: "
                    if "description" in module: 
                        readme = readme+module["description"][0].lower()+module["description"][1:]
                    readme = readme+"\n"
                    if "module_configuration" in module: 
                        readme = readme+"  - Module configuration:\n"
                        for entry in module["module_configuration"]:
                            required = "*" if "required" in entry and entry["required"] else ""
                            placeholder = " (e.g. "+str(entry["placeholder"])+")" if "placeholder" in entry else ""
                            readme = readme+"    - *"+entry["name"]+"*"+required+": "+entry["description"][0].lower()+entry["description"][1:]+placeholder+"\n"
                    if "service_configuration" in module: 
                        readme = readme+"  - Service configuration:\n"
                        for mode in module["service_configuration"]:
                            readme = readme+"    - Mode '"+mode+"':\n"
                            for entry in module["service_configuration"][mode]:
                                required = "*" if "required" in entry and entry["required"] else ""
                                placeholder = " (e.g. "+str(entry["placeholder"])+")" if "placeholder" in entry else ""
                                readme = readme+"      - *"+entry["name"]+"*"+required+": "+entry["description"][0].lower()+entry["description"][1:]+placeholder+"\n"
        readme = readme+"\n## Contribute\n\n"
        readme = readme+"If you are the author of this package, simply clone the repository, apply any change you would need and run the following command from within this package's directory to commit your changes and automatically push them to Github:\n"
        readme = readme+"```\negeoffrey-cli commit \"<comment>\"\n```\n"
        readme = readme+"After taking this action, remember you still need to build (see below) the package (e.g. the Docker image) to make it available for installation.\n\n"
        readme = readme+"If you are a user willing to contribute to somebody's else package, submit your PR (Pull Request); the author will take care of validating your contributation, merging the new content and building a new version.\n"
        readme = readme+"\n## Build\n\n"
        readme = readme+"Building is required only if you are the author of the package. To build a Docker image and automatically push it to [Docker Hub](https://hub.docker.com/r/"+manifest["dockerhub"]+"), run the following command from within this package's directory:\n"
        readme = readme+"```\negeoffrey-cli build "+manifest["package"]+" <amd64|arm>\n```\n"
        if "container_config" in manifest:
            readme = readme+"To function properly, when running in a Docker container, the following additional configuration settings has to be added to e.g. your docker-compose.yml file (when installing through egeoffrey-cli, this is not needed since done automatically upon installation):\n"
            readme = readme+"```\n"+yaml.safe_dump(manifest["container_config"], default_flow_style=False)+"```\n"
        readme = readme+"\n## Uninstall\n\n"
        readme = readme+"To uninstall this package, run the following command from within your eGeoffrey installation directory:\n"
        readme = readme+"```\negeoffrey-cli uninstall "+manifest["package"]+"\n```\n"
        readme = readme+"Remember to run also `egeoffrey-cli start` to ensure the changes are correctly applied."
        readme = readme+"\n## Tags\n\n"
        readme = readme+"The following tags are associated to this package:\n"
        readme = readme+"```\n"+manifest["tags"]+"\n```\n"
        readme = readme+"\n## Version\n\n"
        readme = readme+"The version of this "+manifest["package"]+" is "+str(manifest["version"])+"-"+str(manifest["revision"])+" on the "+str(manifest["branch"])+" branch.\n"
        # save the README file
        try:
            f = open(MY_DIRECTORY+"/README.md", "w")
            f.write(readme)
            f.close()
        except Exception,e:
            print_error("Unable to save README file: "+str(e))
        # add the new files to git 
        print_output(run_git(["add", "."]))
        # print out the status
        print_output(run_git(["status"]))
        print_output("\nPublishing changes to the remote repository...")
        # commit the changes
        print_output(run_git(["commit", "-m", ARGUMENTS]))
        if not OFFLINE:
            # push the changes to the remote repository
            print_output(run_git(["push", "origin", manifest["branch"]]))
            # TODO: for master branch, tag with version number
    else:
        print_output("Nothing to commit on "+manifest["package"])

# build a docker image and push upstream
elif COMMAND == "build":    
    if ARGUMENTS == "": print_error("provide an architecture or a set of architectures to build against (e.g. amd64, arm)")
    architectures = ARGUMENTS.split(",")
    # read the manifest file
    manifest = read_manifest(MY_DIRECTORY+"/manifest.yml")
    # for each architecture
    for architecture in architectures:
        if architecture not in ["amd64", "arm"]: print_error("Invalid architecture "+architecture)
        if architecture == "arm": architecture = "arm32v6"
        # build the docker image
        image = manifest["dockerhub"]+":"+manifest["branch"]+"-"+architecture
        print_output("\nBuilding docker image "+image+"...")
        run_docker(["build", "--rm", "--build-arg", "SDK_VERSION="+SDK_BRANCH, "--build-arg", "ARCHITECTURE="+architecture, "--tag", image, MY_DIRECTORY])
        if not OFFLINE:
            # push the image to dockerhub
            print_output("\nPublishing docker image "+image+"...")
            run_docker(["push", image])
            # TODO: for master branch, tag with version number
        
# build a docker image and push upstream
elif COMMAND == "build_sdk":
    ARGUMENTS = ARGUMENTS.split(" ")
    if len(ARGUMENTS) != 2: print_error("provide a SDK image and architecture(s) to build against")
    sdk_image = ARGUMENTS[0]
    architectures = ARGUMENTS[1].split(",")
    # read the manifest file
    manifest = read_manifest(MY_DIRECTORY+"/sdk/manifest.yml")
    # for each architecture
    for architecture in architectures:
        if architecture not in ["amd64", "arm"]: print_error("Invalid architecture "+architecture)
        if architecture == "arm" : architecture = "arm32v6"
        # build the docker image
        image = manifest["dockerhub"]+"-"+sdk_image+":"+manifest["branch"]+"-"+architecture
        print_output("\nBuilding docker image "+image+"...")
        run_docker(["build", "--rm", "--file", MY_DIRECTORY+"/Dockerfile-"+sdk_image, "--build-arg", "ARCHITECTURE="+architecture, "--tag", image, MY_DIRECTORY])
        if not OFFLINE:
            # push the image to dockerhub
            print_output("\nPublishing docker image "+image+"...")
            run_docker(["push", image])
    
# make a collection using the files provided in the collection directory
elif COMMAND == "make_collection":
    # variables
    collection_dir = MY_DIRECTORY+"/collection"
    if not os.path.isdir(collection_dir):
        print_error("Collection configuration directory not found at "+collection_dir)
    build_dir = collection_dir+"/.build"
    tmp_dir = collection_dir+"/.tmp"
    dockerfile_collection = {}
    dockerfile_collection["arg"] = []
    dockerfile_collection["from"] = None
    dockerfile_collection["apt-get"] = []
    dockerfile_collection["apk"] = []
    dockerfile_collection["pip"] = []
    dockerfile_collection["others"] = []
    dockerfile_collection["copy"] = []
    gitignore_collection = []
    dockerignore_collection = []
    # clean up
    run("rm -rf "+build_dir)
    run("rm -rf "+tmp_dir)
    run("mkdir -p "+build_dir)
    run("mkdir -p "+build_dir+"/manifests")
    run("mkdir -p "+tmp_dir)
    # read - if exists - the existing manifest
    old_manifest = None
    if os.path.exists(MY_DIRECTORY+"/manifest.yml"):
        try:
            with open(MY_DIRECTORY+"/manifest.yml") as f: content = f.read()
            old_manifest = yaml.load(content, Loader=yaml.SafeLoader)
        except Exception,e:
            print_error("Unable to read manifest file: "+str(e))
    # read the collection manifest file
    try:
        with open(collection_dir+"/manifest.yml") as f: content = f.read()
        manifest_collection = yaml.load(content, Loader=yaml.SafeLoader)
    except Exception,e:
        print_error("Unable to read collection manifest: "+str(e))
    # parse the provided list of packages to add
    packages = []
    try:
        with open(collection_dir+"/packages.txt") as f: content = f.read()
        for line in content.split("\n"):
            # clean up the file
            line = line.replace(" ", "")
            if line.startswith("#"): continue
            if line == "": continue
            packages.append(line)
    except Exception,e: 
        print_error("unable to open repo list: "+str(e))
    print_output("Building collection "+manifest_collection["package"]+" with "+str(len(packages))+" packages")
    # for each package
    for package in packages:
        # get package name from the repo URL
        repo, branch = package.split(":")
        user , package_name = repo.split("/")
        print_output("Adding package "+package_name+"...")
        # download the package
        package_tar_file = tmp_dir+"/"+package_name+".tar.gz"
        package_tmp_dir = tmp_dir+"/"+package_name
        package_url = "https://github.com/"+repo+"/archive/"+branch+".tar.gz"
        print_debug("Downloading "+package_url+"...")
        run("wget "+package_url+" -O "+package_tar_file)
        # extract the package's content
        print_debug("Extracting "+package_tar_file+"...")
        run("mkdir "+package_tmp_dir)
        run("tar zxfv "+package_tar_file+" --strip-components=1 -C "+package_tmp_dir)
        # read the package's manifest
        manifest_file = package_tmp_dir+"/manifest.yml"
        try:
            with open(manifest_file) as f: content = f.read()
            manifest = yaml.load(content, Loader=yaml.SafeLoader)
        except Exception,e:
            print_error("Unable to load manifest of "+package_name+": "+str(e))
        run("cp -f "+manifest_file+" "+build_dir+"/manifests/manifest_"+manifest["package"]+".yml")
        # update the collection manifest file by merging the package's modules
        for module_object in manifest["modules"]:
            manifest_collection["modules"].append(module_object)
        # update the collection manifest file by merging container_config
        if "container_config" in manifest:
            if "container_config" not in manifest_collection:
                manifest_collection["container_config"] = {}
            manifest_collection["container_config"].update(manifest["container_config"])
        # read the package's Dockerfile
        dockerfile = package_tmp_dir+"/Dockerfile"
        try:
            with open(dockerfile) as f: content = f.read()
        except Exception,e:
            print_error("Unable to load Dockerfile of "+package_name+": "+str(e))
        content = content.replace("\r\n", "\n").replace("\\\n", " ")
        # parse the Dockerfile
        for line in content.split("\n"):
            if line == "" or line[0] == "#": continue
            # if the same line skip it
            if line in dockerfile_collection: continue
            elif line.startswith("ARG "):
                if line not in dockerfile_collection["arg"]:
                 dockerfile_collection["arg"].append(line)
            elif line.startswith("FROM "):
                if dockerfile_collection["from"] is None:
                    dockerfile_collection["from"] = line
                else:
                    if line != dockerfile_collection["from"]:
                        print_error(package_name+" is belonging to a different base image than the others")
            elif line.startswith("RUN apt-get "):
                apt_get_packages = line.replace("RUN apt-get update && apt-get install -y ", "").replace(" && apt-get clean && rm -rf /var/lib/apt/lists/*", "").split(" ")
                for apt_get_package in apt_get_packages:
                    if apt_get_package not in dockerfile_collection["apt-get"]:
                        dockerfile_collection["apt-get"].append(apt_get_package)
            elif line.startswith("RUN apk "):
                apk_packages = line.replace("RUN apk update && apk add ", "").replace(" && rm -rf /var/cache/apk/*", "").split(" ")
                for apk_package in apk_packages:
                    if apk_package not in dockerfile_collection["apk"]:
                        dockerfile_collection["apk"].append(apk_package)
            elif line.startswith("RUN pip "):
                if line == "RUN pip install --upgrade setuptools": continue
                # if there are package-specific install options, isolate the command
                if "--install-option" in line:
                    dockerfile_collection["others"].append(line)
                else:
                    pip_packages = line.replace("RUN pip install ", "").split(" ")
                    for pip_package in pip_packages:
                        if pip_package not in dockerfile_collection["pip"]:
                            dockerfile_collection["pip"].append(pip_package)
            elif line.startswith("COPY "):
                if line not in dockerfile_collection["copy"]:
                    dockerfile_collection["copy"].append(line)
            else:
                dockerfile_collection["others"].append(line)
        # read .gitignore file
        gitignore_file = package_tmp_dir+"/.gitignore"
        if os.path.exists(gitignore_file): 
            try:
                with open(gitignore_file) as f: content = f.read()
            except Exception,e:
                print_error("Unable to load .gitignore of "+package_name+": "+str(e))
            content = content.replace("\r\n", "\n")
            # parse the file
            for line in content.split("\n"):
                if line == "" or line[0] == "#": continue
                # if the same line skip it
                if line in gitignore_collection: continue
                gitignore_collection.append(line)
        # read .dockerignore file
        dockerignore_file = package_tmp_dir+"/.dockerignore"
        if os.path.exists(dockerignore_file): 
            try:
                with open(dockerignore_file) as f: content = f.read()
            except Exception,e:
                print_error("Unable to load .dockerignore of "+package_name+": "+str(e))
            content = content.replace("\r\n", "\n")
            # parse the file
            for line in content.split("\n"):
                if line == "" or line[0] == "#": continue
                # if the same line skip it
                if line in dockerignore_collection: continue
                dockerignore_collection.append(line)
        # move all the files of the downloaded packages in the build directory
        for (current_path, dirnames, filenames) in os.walk(package_tmp_dir): 
            for filename in filenames:
                package_tmp_file = current_path+os.sep+filename
                build_file = package_tmp_file.replace(package_tmp_dir, build_dir, 1)
                build_parent_dir = build_file.replace(filename, "", 1)
                if not os.path.exists(build_parent_dir): 
                    os.makedirs(build_parent_dir)
                run("mv -f "+package_tmp_file+" "+build_file)
    # build and save the collection Dockerfile
    try: 
        f = open(build_dir+"/Dockerfile", "w")
        for arg in dockerfile_collection["arg"]:
            f.write(arg+"\n")
        f.write(dockerfile_collection["from"]+"\n")
        if len(dockerfile_collection["apt-get"]) > 0:
            f.write("RUN apt-get update && apt-get install -y "+" ".join(dockerfile_collection["apt-get"])+" && apt-get clean && rm -rf /var/lib/apt/lists/*\n")
        if len(dockerfile_collection["apk"]) > 0:
            f.write("RUN apk update && apk add "+" ".join(dockerfile_collection["apk"])+" && rm -rf /var/cache/apk/*\n")
        if len(dockerfile_collection["pip"]) > 0:
            f.write("RUN pip install --upgrade setuptools && pip install "+" ".join(dockerfile_collection["pip"])+"\n")
        for line in dockerfile_collection["others"]:
            f.write(line+"\n")
        for line in dockerfile_collection["copy"]:
            f.write(line+"\n")
        f.close()
    except Exception,e:
        print_error("Unable to save collection Dockerfile: "+str(e))
    # build and save .gitignore
    if len(gitignore_collection) > 0:
        try: 
            f = open(build_dir+"/.gitignore", "w")
            for line in gitignore_collection:
                f.write(line+"\n")
            f.write(tmp_dir.replace(MY_DIRECTORY+"/", "", 1)+"\n")
            f.write(build_dir.replace(MY_DIRECTORY+"/", "", 1)+"\n")
            f.close()
        except Exception,e:
            print_error("Unable to save collection .gitignore: "+str(e))
    # build and save .dockerignore
    if len(dockerignore_collection) > 0:
        try: 
            f = open(build_dir+"/.dockerignore", "w")
            for line in dockerignore_collection:
                f.write(line+"\n")
            f.write(tmp_dir.replace(MY_DIRECTORY+"/", "", 1)+"\n")
            f.write(build_dir.replace(MY_DIRECTORY+"/", "", 1)+"\n")
            f.write(tmp_dir.replace(MY_DIRECTORY+"/", "", 1)+"/\n")
            f.write(build_dir.replace(MY_DIRECTORY+"/", "", 1)+"/\n")
            f.close()
        except Exception,e:
            print_error("Unable to save collection .gitignore: "+str(e))
    # keep track of the old revision number in the manifest file
    if old_manifest is not None:
        manifest_collection["revision"] = old_manifest["revision"]
    # build and save the collection manifest file
    try: 
        f = open(build_dir+"/manifest.yml", "w")
        f.write(yaml.safe_dump(manifest_collection, default_flow_style=False))
        f.close()
    except Exception,e:
        print_error("Unable to save collection manifest file: "+str(e))
    # for each file of the build directory check if needs to be moved into the main directory
    created = 0
    updated = 0
    deleted = 0
    for (current_path, dirnames, filenames) in os.walk(build_dir): 
        for filename in filenames:
            build_file = current_path+os.sep+filename
            target_file = build_file.replace(build_dir, MY_DIRECTORY, 1)
            target_dir = target_file.replace(filename, "", 1)
            # if this is a new or updated file, overwrite it
            if not os.path.exists(target_file):
                print_debug("Creating "+target_file)
                if not os.path.exists(target_dir): 
                    os.makedirs(target_dir)
                run("cp -f "+build_file+" "+target_file)            
                created = created+1
            elif not filecmp.cmp(build_file, target_file):
                print_debug("Updating "+target_file)
                if not os.path.exists(target_dir): 
                    os.makedirs(target_dir)
                run("cp -f "+build_file+" "+target_file)            
                updated = updated+1
    # for each file of the main directory check if exists in the build directory, otherwise, delete it
    for (current_path, dirnames, filenames) in os.walk(MY_DIRECTORY): 
        for filename in filenames:
            if current_path.startswith(collection_dir) or current_path.startswith(MY_DIRECTORY+"/.git"): continue
            target_file = current_path+os.sep+filename
            build_file = target_file.replace(MY_DIRECTORY, build_dir, 1)
            # if the file does not exist anymore, delete it
            if not os.path.exists(build_file):
                print_debug("Deleting "+target_file)
                deleted = deleted+1
                if os.path.isdir(target_file):
                    run("rm -rf "+target_file)
                else:
                    run("rm -f "+target_file)
                    # if there are no more files in the directory, delete it
                    if len([name for name in os.listdir(current_path) if os.path.isfile(os.path.join(current_path, name))]) == 0:
                        run("rmdir "+current_path)
    print_output("Done. "+str(created)+" files created, "+str(updated)+" files updated, "+str(deleted)+" files deleted")
    # clean up
    run("rm -rf "+tmp_dir)
    run("rm -rf "+build_dir)
    
## MAIN - GENERAL ##

# upgrade egeoffrey-cli to the latest version
elif COMMAND == "upgrade":
    # upgrade needed
    version = requires_upgrade()
    if version is not None:
        # download the latest version
        try:
            response = requests.get(MY_DOWNLOAD_URL+"?timestamp="+str(int(time.time())))
            if response.status_code != 200: print_error("Unable to download the newest version of egeoffrey-cli")
        except Exception,e:
            print_error("Unable to download the newest version of egeoffrey-cli: "+str(e))
        # replace this file
        try:
            f = open("/usr/local/bin/egeoffrey-cli", "w")
            f.write(response.content)
            f.close()
        except Exception,e:
            print_error("Unable to install the latest version: "+str(e))
        print_output("Upgrade to version v"+version+" ("+str(BRANCH)+") successful")
    else:
        print_output("Already at the latest version - v"+str(VERSION)+"-"+str(REVISION)+" ("+str(BRANCH)+")")

# print out this script version
elif COMMAND == "version":
    print_output("egeoffrey-cli v"+str(VERSION)+"-"+str(REVISION)+" ("+str(BRANCH)+")")

else:
    print_usage()

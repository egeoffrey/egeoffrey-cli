#!/usr/bin/python

import sys
import os
import re
import time
import json
import yaml
import subprocess
import requests
import filecmp

## constants
BRANCH = "development"
VERSION = 1.0
REVISION = 17
MARKETPLACE_URL = "https://api.github.com/repos/egeoffrey/egeoffrey-marketplace/contents/marketplace"
MARKETPLACE_BRANCH = "master"
SDK_BRANCH = "development"
MY_MANIFEST_URL = "https://raw.githubusercontent.com/egeoffrey/egeoffrey-cli/"+BRANCH+"/version.yml"
MY_DOWNLOAD_URL = "https://raw.githubusercontent.com/egeoffrey/egeoffrey-cli/"+BRANCH+"/egeoffrey-cli"
MY_DIRECTORY = os.getcwd()
DOCKER_COMPOSE = "docker-compose.yml"
SUPPORTED_MANIFEST_SCHEMA = 2

## variables
# debug output 
debug = False
# do not require user interaction
quite = False
# do not push anything out
offline = False
# requested command
command = ""
# arguments to the requested command
arguments = ""
# docker-compose .env 
env = {}
# docker-compose configuration
config = {}

# print out an error message and exit
def print_error(message):
    print "\033[91mERROR\033[0m: "+str(message)
    exit(1)
    
# print out a warning message
def print_warning(message):
    print "\033[33mWARNING\033[0m: "+str(message)
    
# print out a debug message
def print_debug(message):
    global debug
    if debug: print message

# print out a message    
def print_output(message):
    print message
    
# parse command line arguments
def parse_command_line():
    global command, arguments, debug, quite, offline, MY_DIRECTORY, DOCKER_COMPOSE
    skip_next = False
    for i in range(1, len(sys.argv)):
        if skip_next: 
            skip_next = False
            continue
        arg = sys.argv[i]
        arg = re.sub(' +',' ', arg)
        if arg == "-d":
            MY_DIRECTORY = sys.argv[i+1].rstrip("/")
            skip_next = True
            continue
        if arg == "-f":
            DOCKER_COMPOSE = sys.argv[i+1]
            skip_next = True
            continue
        if arg == "-v":
            debug = True
            continue
        if arg == "-o":
            offline = True
            continue
        if arg == "-q":
            quite = True
            continue
        if command == "":
            command = arg
            continue
        arguments = arguments+" "+arg
    arguments = arguments.strip()
    print_debug("Base directory: "+MY_DIRECTORY)
    print_debug("Command: "+command)
    print_debug("Arguments: "+arguments)
    
# check if the cli requires to be upgraded
def requires_upgrade():
    # download the manifest from github which contains the latest version number
    print_debug("Downloading egeoffrey-cli manifest from "+MY_MANIFEST_URL)
    try:
        response = requests.get(MY_MANIFEST_URL+"?timestamp="+str(int(time.time())))
        if response.status_code != 200: print_error("Unable to download egeoffrey-cli manifest")
        manifest =  yaml.load(response.content, Loader=yaml.SafeLoader)
    except Exception,e:
        print_error("Unable to download egeoffrey-cli manifest: "+str(e))
    # check if we are at the latest version
    print_debug("egeoffrey-cli latest release v"+str(manifest["revision"])+", currently running v"+str(REVISION))
    if manifest["version"] > VERSION or (manifest["version"] == VERSION and manifest["revision"] > REVISION): return str(manifest["version"])+"-"+str(manifest["revision"])
    return None
    
# load .env file with common docker-compose environment variables
def load_env():
    global env
    env_file = MY_DIRECTORY+"/.env"
    if not os.path.isfile(env_file):
        print_error("the configuration file '.env' cannot be found in "+env_file+". Please switch into eGeoffrey installation directory or provide the directory with the -d option")
    try:
        with open(env_file) as f: content = f.read()
        for line in content.split("\n"):
            # clean up the file
            line = re.sub(' +',' ', line).replace('"', "")
            if line.startswith("#"): continue
            if "=" not in line: continue
            split = line.split("=")
            # store it into the env variable
            env[split[0]] = split[1]
    except Exception,e: 
        print_error("unable to read environment file from "+env_file+": "+str(e))
    print_debug("Loaded "+str(len(env))+" env settings")

# download and return a manifest from a remote git repository
def get_manifest(package, repository, branch):
    print_debug("Loading manifest file for package "+package+":"+branch)
    try:
        manifest_url = "https://raw.githubusercontent.com/"+repository+"/"+branch+"/manifest.yml?timestamp="+str(int(time.time()))
        response = requests.get(manifest_url)
        if response.status_code != 200: 
            print_warning("skipping package "+package+":"+branch)
            return None
        return yaml.load(response.content, Loader=yaml.SafeLoader)
    except Exception,e:
        print_warning("skipping package "+package+":"+branch+": "+str(e))
        return None    

# return an array of registered packages in the marketplace
def list_marketplace():
    index = []
    print_debug("Listing Marketplace items...")
    try:
        # list all files in the marketplace database
        response = requests.get(MARKETPLACE_URL+"?ref="+MARKETPLACE_BRANCH)
        if response.status_code != 200: print_error("Unable to list marketplace items")
        content = json.loads(response.content)
        # for each package in the marketplace
        for entry in content:
            if "path" not in entry or "name" not in entry: continue
            index.append(entry["name"].replace(".yml", ""))
        print_debug("Marketplace has "+str(len(content))+" entries")
        return index
    except Exception,e:
        print_error("Unable to list marketplace items: "+str(e))

# return the github repo of a marketplace package 
def get_repository(package):
    try: 
        # download from the marketplace the file for the package
        response = requests.get("https://raw.githubusercontent.com/egeoffrey/egeoffrey-marketplace/"+MARKETPLACE_BRANCH+"/marketplace/"+package+".yml?timestamp="+str(int(time.time())))
        if response.status_code != 200: print_error("Unable to retrieve github repository for package "+package)
        content = yaml.load(response.content, Loader=yaml.SafeLoader)
        if "github" not in content: return None
        return content["github"]
    except Exception,e:
        print_error("Unable to retrieve github repository for package "+package+": "+str(e))
        
# parse a package splitting the package name from the branch
def parse_package(string):
    package = string
    branch = "master"
    if ":" in string: package, branch = string.split(":", 1)
    return package, branch        
    
# build the marketplace database
def get_marketplace(requested_packages=None, package_branch="master"):
    global env
    marketplace = {}
    # get the list of all items in the marketplace
    marketplace_index = list_marketplace()
    try:
        # for each package in the marketplace
        for i in range(0, len(marketplace_index)):
            marketplace_package = marketplace_index[i]
            # no specific package requested, tell the user we need to download the entire marketplace
            if requested_packages is None:
                msg = "Downloading marketplace database: "+str( (i+1)*100/len(marketplace_index) )+"%"
                sys.stdout.write('\r')
                sys.stdout.write(msg)
                sys.stdout.flush()
                if i == len(marketplace_index)-1: sys.stdout.write('\n')
            # if specific packages are requested, filter out unwanted packages
            if requested_packages is not None:
                include_package = False
                for package in requested_packages:
                    package_name, package_branch = parse_package(package)
                    if package_name == marketplace_package: include_package = True
                if not include_package: continue
            # download the marketplace item which contains the github repo reference
            repository = get_repository(marketplace_package)
            if repository is None: continue
            # download the manifest from the remote repository
            manifest = get_manifest(marketplace_package, repository, package_branch)
            if manifest is None: continue
            if manifest["manifest_schema"] != SUPPORTED_MANIFEST_SCHEMA:
                print_warning("Skipping package "+marketplace_package+" because manifest v"+str(manifest["manifest_schema"])+" is not supported")
                continue
            # populate the marketplace
            marketplace[marketplace_package] = manifest
        return marketplace
    except Exception,e:
        print_error("Unable to build marketplace index: "+str(e))
        
# load docker-compose configuration
def load_configuration():
    global config
    docker_compose_file = MY_DIRECTORY+"/"+DOCKER_COMPOSE
    # load docker-compose common variables
    load_env()
    # if docker-compose file does not exist, make an empty version
    if not os.path.isfile(docker_compose_file): 
        config = {
            "version": "3",
            "services": {},
            "networks": {
                "egeoffrey": {
                    "driver": "bridge"
                }
            }
        }
    else:
        print_debug("Loading docker-compose configuration from "+docker_compose_file)
        try:
            with open(docker_compose_file) as f: content = f.read()
            config = yaml.load(content, Loader=yaml.SafeLoader)
        except Exception,e:
            print_error("Unable to load eGeoffrey docker configuration: "+str(e))
        
# save docker-compose configuration
def save_configuration():
    global config
    docker_compose_file = MY_DIRECTORY+"/"+DOCKER_COMPOSE
    print_debug("Saving docker-compose configuration to "+docker_compose_file)
    try: 
        f = open(docker_compose_file, "w")
        f.write(yaml.safe_dump(config, default_flow_style=False))
        f.close()
    except Exception,e:
        print_error("Unable to save eGeoffrey docker configuration: "+str(e))
       
# run a command    
def run(command):
    return subprocess.Popen(command, shell=True, stdout=subprocess.PIPE,  stderr=subprocess.PIPE).stdout.read()

# run docker-compose
def run_docker_compose(args):
    current_dir = os.getcwd()
    # when docker-compose runs in a container cannot mount the target directory, let's chdir into it first
    os.chdir(MY_DIRECTORY)
    docker_compose_file = MY_DIRECTORY+"/"+DOCKER_COMPOSE
    subprocess.call(["docker-compose", "-f", docker_compose_file] + args)
    # get back to the original directory
    os.chdir(current_dir)
    
# run docker
def run_docker(args):
    subprocess.call(["docker"] + args)

# run git
def run_git(args):
    return subprocess.check_output(["git", "-C", MY_DIRECTORY] + args)
    
# read and return a (local) manifest file
def read_manifest(manifest_file):
    if not os.path.isfile(manifest_file):
        print_error("Unable to find a manifest file in "+MY_DIRECTORY)
    try:
        with open(manifest_file) as f: content = f.read()
        manifest = yaml.load(content, Loader=yaml.SafeLoader)
    except Exception,e:
        print_error("Invalid manifest file in "+MY_DIRECTORY+": "+str(e))
    if manifest["manifest_schema"] != SUPPORTED_MANIFEST_SCHEMA:
        print_error("manifest v"+str(manifest["manifest_schema"])+" is not supported")
    return manifest
    
# print usage
def print_usage():
    print_output("egeoffrey-cli v"+str(VERSION)+"-"+str(REVISION)+" ("+str(BRANCH)+")")
    print_output("Usage: egeoffrey-cli [OPTIONS] COMMAND ARGUMENTS")
    print_output("")
    print_output("Options:")
    print_output("  -d <directory>                      set the working directory")
    print_output("  -f <filename>                       set custom docker-compose.yml filename")
    print_output("  -v                                  enable debug output")
    print_output("  -q                                  quite mode - do not run interactively")
    print_output("  -o                                  offline mode")
    print_output("")
    print_output("General commands:")
    print_output("  upgrade                             Upgrade egeoffrey-cli to the latest version")
    print_output("  version                             Print out this script version")
    print_output("")
    print_output("Run commands:")
    print_output("  info <package>                      Print out information on a given package")
    print_output("  install <package(s)>                Install the provided package(s)")
    print_output("  list_available [<branch>]           List available packages that can be installed")
    print_output("  list_installed                      List already installed packages")
    print_output("  logs [-f] [<package(s)>]            Print out log information")
    print_output("  reload                              Reload the configuration")
    print_output("  search <string> [branch]            Search packages matching the provided description")
    print_output("  start [<package(s)>]                Start configured services")
    print_output("  stats                               Print out running packages CPU and memory utilization")
    print_output("  status                              Show currently running components")
    print_output("  stop                                Stop running services")
    print_output("  update [<package(s)>]               Update the installed package(s)")
    print_output("  uninstall [<package(s)>]            Uninstall the provided package(s)")
    print_output("")
    print_output("Build commands:")
    print_output("  commit '<description>'              Commit changes to the local and remote git repository")
    print_output("  build <amd64,arm>                   Build a docker image and push it upstream")
    print_output("  build_sdk <image> <amd64,arm>       Build a SDK docker image and push it upstream")
    print_output("  make_distro                         Create a distro including the configured packages")

        
## MAIN - RUN ##

# parse provided command line
parse_command_line()
# check if running the latest version
if not offline:
    version = requires_upgrade()
    if version is not None: print_warning("a new version of egeoffrey-cli is available ("+version+"), run 'egeoffrey-cli upgrade' to upgrade")

# do what requested by the user

# print out information on a given package
if command == "info":
    package = arguments
    if package == "": print_error("a package name must be provided")
    marketplace = get_marketplace([package])
    package_name, package_branch = parse_package(package)
    if package_name not in marketplace: print_error("package "+package+" not found")
    manifest = marketplace[package_name]
    print_output("Package: "+manifest["package"])
    print_output("Tags: "+manifest["tags"])
    print_output("Version: "+str(manifest["version"])+"-"+str(manifest["revision"])+" ("+str(manifest["branch"])+")")
    print_output("Github: https://github.com/"+manifest["github"])
    print_output("Docker: "+manifest["dockerhub"])
    modules = []
    for module_object in manifest["modules"]:
        for module in module_object:
            modules.append(module)
    print_output("Modules: "+", ".join(modules))
    print_output("")
    print_output(manifest["description"])
    print_output("")
    
# install a package
elif command == "install":
    load_configuration()
    packages = arguments.split(" ")
    if len(packages) == 0: print_error("at least a package name must be provided")
    marketplace = get_marketplace(packages)
    for package in packages:
        package_name, package_branch = parse_package(package)
        # ensure package is not already installed
        if package_name in config["services"]:
            print_output(package_name+" is already installed")
            continue
        # ensure package exists in the marketplace
        if package_name not in marketplace:
            print_output(package_name+" not found in the marketplace, skipping")
            continue
        # add the package to the docker-compose file
        try:
            service = {}
            manifest =  marketplace[package_name]
            print_debug("Installing package "+package_name+":"+package_branch)
            # if runtime parameters are provided, merge them with the service
            if "container_config" in manifest: 
                print_debug("Container default runtime: "+str(manifest["container_config"]))
                service.update(manifest["container_config"])
            # add env_file
            service["env_file"] = ".env"
            # add image
            service["image"] = manifest["dockerhub"]+":"+package_branch+"-"+env["ARCHITECTURE"]
            # add EGEOFFREY_MODULES variable
            if "modules" in manifest:
                modules = []
                for module_object in manifest["modules"]:
                    for module in module_object:
                        modules.append(module)
                if len(modules) > 0:
                    if "environment" not in service: service["environment"] = []
                    service["environment"].append("EGEOFFREY_MODULES="+", ".join(modules))
            # link to the default bridge network if no other instructions are provided
            if "network_mode" not in service and "networks" not in service:
                service["networks"] = []
                service["networks"].append("egeoffrey")
            # if there is a volume mapping, create the local MY_DIRECTORY
            if "volumes" in service:
                for volume in service["volumes"]:
                    volume = volume.replace('"', "")
                    split = volume.split(":")
                    directory = split[0]
                    if not os.path.exists(directory):
                        print_debug("Creating directory "+directory)
                        os.makedirs(directory)
            if "devices" in service:
                for device in service["devices"]:
                    device = device.replace('"', "")
                    split = device.split(":")
                    print_output("Please ensure the mapped device "+split[0]+" exists")
            # the docker daemon will restart the service at boot time
            # TODO: add restart = always
            #service["restart"] = "always"
            # add the new service
            config["services"][package_name] = service
        except Exception,e:
            print_error("installation of package "+package_name+":"+package_branch+" failed: "+str(e))
        print_output(package_name+":"+package_branch+" installed successfully")
    # save the updated configuration file
    save_configuration()
    
# list packages available to install
elif command == "list_available":
    load_configuration()
    branch = arguments if arguments != "" else "master"
    marketplace = get_marketplace(None, branch)
    for package in sorted(marketplace):
        # skip already installed packages
        if package in config["services"]: continue
        print_output(package+": "+marketplace[package]["description"])

# list packages already installed
elif command == "list_installed":
    load_configuration()
    for service in sorted(config["services"]):
        print_output(service)
        
# run docker logs
elif command == "logs":
    options = arguments.split(" ") if arguments != "" else []
    run_docker_compose(["logs"]+options)
    
# reload the configuration
elif command == "reload":
    run_docker_compose(["up", "-d", "--remove-orphans"])

# search for a package
elif command == "search":
    search = arguments.split(" ")
    if len(search) == 0 or len(search) > 2: print_error("invalid search string provided")
    branch = "master"
    if len(search) == 2: branch = search[1]
    load_configuration()
    marketplace = get_marketplace(None, branch)
    words = search[0].split(" ")
    for package in sorted(marketplace):
        if len(list(set(words) & set(marketplace[package]["description"].split(" ")))) > 0 or len(list(set(words) & set(marketplace[package]["tags"].split(" ")))) > 0:
            print_output(package+": "+marketplace[package]["description"])
            
# start services
elif command == "start":
    packages = arguments.split(" ") if arguments != "" else []
    run_docker_compose(["up", "-d", "--remove-orphans"]+packages)
    
# run docker stats
elif command == "stats":
    run_docker(["stats", "--no-stream"])

# run docker ps
elif command == "status":
    run_docker_compose(["ps"])

# stop services
elif command == "stop":
    run_docker_compose(["down"])
    
# update an installed packages
elif command == "update":
    packages = arguments.split(" ") if arguments != "" else []
    run_docker_compose(["pull"]+packages)
    
# uninstall a package
elif command == "uninstall":
    load_configuration()
    packages = arguments.split(" ")
    if len(packages) == 0: print_error("at least a package name must be provided")
    for package in packages:
        package_name, package_branch = parse_package(package)
        # ensure package is installed
        if package_name not in config["services"]:
            print_output(package_name+" is not installed")
            continue
        # remove the package from the docker-compose file
        del config["services"][package_name]
        print_output(package_name+" uninstalled successfully")
    # save the updated configuration file
    save_configuration()
    
## MAIN - BUILD ##

# commit changes to a git repository and push upstream
elif command == "commit":
    if arguments == "": print_error("provide a description for this commit")
    # read the manifest file
    manifest_file = MY_DIRECTORY+"/manifest.yml"
    manifest = read_manifest(manifest_file)
    # ensure we are in the same branch of the manifest
    output = run_git(["branch"])
    branch = None
    for line in output.split("\n"):
        if line.startswith("* "): branch = line.replace("* ","")
    if branch is None: print_error("unable to determine current branch of "+MY_DIRECTORY)
    if branch != manifest["branch"]: print_error(MY_DIRECTORY+" current branch does not match with the manifest's branch")
    if "nothing to commit" not in run_git(["status"]):
        # ask the user before proceeding
        if not quite:
            # add the new files to git
            print_output(run_git(["add", "."]))
            print_output(run_git(["status"]))
            raw_input("Do you want to proceed committing these changes?")
        # increase revision number
        manifest["revision"] = manifest["revision"]+1
        # convert the manifest back to YAML
        try:
            content = yaml.safe_dump(manifest, default_flow_style=False)
        except Exception,e:
            print_error("unable to edit the manifest file: "+str(e))
        # save the updated manifest
        try:
            f = open(manifest_file, "w")
            f.write(content)
            f.close()
        except Exception,e:
            print_error("unable to write the manifest file: "+str(e))
        print_output("Setting new version for "+manifest["package"]+" to "+str(manifest["version"])+"-"+str(manifest["revision"])+" ("+str(manifest["branch"])+")")
        # add the new files to git 
        print_output(run_git(["add", "."]))
        # print out the status
        print_output(run_git(["status"]))
        print_output("\nPublishing changes to the remote repository...")
        # commit the changes
        print_output(run_git(["commit", "-m", arguments]))
        if not offline:
            # push the changes to the remote repository
            print_output(run_git(["push", "origin", manifest["branch"]]))
            # TODO: for master branch, tag with version number
    else:
        print_output("Nothing to commit on "+manifest["package"])

# build a docker image and push upstream
elif command == "build":    
    if arguments == "": print_error("provide an architecture or a set of architectures to build against (e.g. amd64, arm)")
    architectures = arguments.split(",")
    # read the manifest file
    manifest = read_manifest(MY_DIRECTORY+"/manifest.yml")
    # for each architecture
    for architecture in architectures:
        if architecture not in ["amd64", "arm"]: print_error("Invalid architecture "+architecture)
        if architecture == "arm": architecture = "arm32v6"
        # build the docker image
        image = manifest["dockerhub"]+":"+manifest["branch"]+"-"+architecture
        print_output("\nBuilding docker image "+image+"...")
        run_docker(["build", "--rm", "--build-arg", "SDK_VERSION="+SDK_BRANCH, "--build-arg", "ARCHITECTURE="+architecture, "--tag", image, MY_DIRECTORY])
        if not offline:
            # push the image to dockerhub
            print_output("\nPublishing docker image "+image+"...")
            run_docker(["push", image])
            # TODO: for master branch, tag with version number
        
# build a docker image and push upstream
elif command == "build_sdk":
    arguments = arguments.split(" ")
    if len(arguments) != 2: print_error("provide a SDK image and architecture(s) to build against")
    sdk_image = arguments[0]
    architectures = arguments[1].split(",")
    # read the manifest file
    manifest = read_manifest(MY_DIRECTORY+"/sdk/manifest.yml")
    # for each architecture
    for architecture in architectures:
        if architecture not in ["amd64", "arm"]: print_error("Invalid architecture "+architecture)
        if architecture == "arm" : architecture = "arm32v6"
        # build the docker image
        image = manifest["dockerhub"]+"-"+sdk_image+":"+manifest["branch"]+"-"+architecture
        print_output("\nBuilding docker image "+image+"...")
        run_docker(["build", "--rm", "--file", MY_DIRECTORY+"/Dockerfile-"+sdk_image, "--build-arg", "ARCHITECTURE="+architecture, "--tag", image, MY_DIRECTORY])
        if not offline:
            # push the image to dockerhub
            print_output("\nPublishing docker image "+image+"...")
            run_docker(["push", image])
    
# make a distro using the files provided in the distro directory
elif command == "make_distro":
    # variables
    distro_dir = MY_DIRECTORY+"/distro"
    if not os.path.isdir(distro_dir):
        print_error("Distribution configuration directory not found at "+distro_dir)
    build_dir = distro_dir+"/.build"
    tmp_dir = distro_dir+"/.tmp"
    dockerfile_distro = {}
    dockerfile_distro["arg"] = []
    dockerfile_distro["from"] = None
    dockerfile_distro["apt-get"] = []
    dockerfile_distro["apk"] = []
    dockerfile_distro["pip"] = []
    dockerfile_distro["others"] = []
    dockerfile_distro["copy"] = []
    gitignore_distro = []
    dockerignore_distro = []
    # clean up
    run("rm -rf "+build_dir)
    run("rm -rf "+tmp_dir)
    run("mkdir -p "+build_dir)
    run("mkdir -p "+build_dir+"/manifests")
    run("mkdir -p "+tmp_dir)
    # read - if exists - the existing manifest
    old_manifest = None
    if os.path.exists(MY_DIRECTORY+"/manifest.yml"):
        try:
            with open(MY_DIRECTORY+"/manifest.yml") as f: content = f.read()
            old_manifest = yaml.load(content, Loader=yaml.SafeLoader)
        except Exception,e:
            print_error("Unable to read manifest file: "+str(e))
    # read the distro manifest file
    try:
        with open(distro_dir+"/manifest.yml") as f: content = f.read()
        manifest_distro = yaml.load(content, Loader=yaml.SafeLoader)
    except Exception,e:
        print_error("Unable to read distro manifest: "+str(e))
    # parse the provided list of packages to add
    packages = []
    try:
        with open(distro_dir+"/packages.txt") as f: content = f.read()
        for line in content.split("\n"):
            # clean up the file
            line = line.replace(" ", "")
            if line.startswith("#"): continue
            if line == "": continue
            packages.append(line)
    except Exception,e: 
        print_error("unable to open repo list: "+str(e))
    print_output("Building distro "+manifest_distro["package"]+" with "+str(len(packages))+" packages")
    # for each package
    for package in packages:
        # get package name from the repo URL
        repo, branch = package.split(":")
        user , package_name = repo.split("/")
        print_output("Adding package "+package_name+"...")
        # download the package
        package_tar_file = tmp_dir+"/"+package_name+".tar.gz"
        package_tmp_dir = tmp_dir+"/"+package_name
        package_url = "https://github.com/"+repo+"/archive/"+branch+".tar.gz"
        print_debug("Downloading "+package_url+"...")
        run("wget "+package_url+" -O "+package_tar_file)
        # extract the package's content
        print_debug("Extracting "+package_tar_file+"...")
        run("mkdir "+package_tmp_dir)
        run("tar zxfv "+package_tar_file+" --strip-components=1 -C "+package_tmp_dir)
        # read the package's manifest
        manifest_file = package_tmp_dir+"/manifest.yml"
        try:
            with open(manifest_file) as f: content = f.read()
            manifest = yaml.load(content, Loader=yaml.SafeLoader)
        except Exception,e:
            print_error("Unable to load manifest of "+package_name+": "+str(e))
        run("cp -f "+manifest_file+" "+build_dir+"/manifests/manifest_"+manifest["package"]+".yml")
        # update the distro manifest file by merging the package's modules
        for module_object in manifest["modules"]:
            manifest_distro["modules"].append(module_object)
        # update the distro manifest file by merging container_config
        if "container_config" in manifest:
            if "container_config" not in manifest_distro:
                manifest_distro["container_config"] = {}
            manifest_distro["container_config"].update(manifest["container_config"])
        # read the package's Dockerfile
        dockerfile = package_tmp_dir+"/Dockerfile"
        try:
            with open(dockerfile) as f: content = f.read()
        except Exception,e:
            print_error("Unable to load Dockerfile of "+package_name+": "+str(e))
        content = content.replace("\r\n", "\n").replace("\\\n", " ")
        # parse the Dockerfile
        for line in content.split("\n"):
            if line == "" or line[0] == "#": continue
            # if the same line skip it
            if line in dockerfile_distro: continue
            elif line.startswith("ARG "):
                if line not in dockerfile_distro["arg"]:
                 dockerfile_distro["arg"].append(line)
            elif line.startswith("FROM "):
                if dockerfile_distro["from"] is None:
                    dockerfile_distro["from"] = line
                else:
                    if line != dockerfile_distro["from"]:
                        print_error(package_name+" is belonging to a different base image than the others")
            elif line.startswith("RUN apt-get "):
                apt_get_packages = line.replace("RUN apt-get update && apt-get install -y ", "").replace(" && apt-get clean && rm -rf /var/lib/apt/lists/*", "").split(" ")
                for apt_get_package in apt_get_packages:
                    if apt_get_package not in dockerfile_distro["apt-get"]:
                        dockerfile_distro["apt-get"].append(apt_get_package)
            elif line.startswith("RUN apk "):
                apk_packages = line.replace("RUN apk update && apk add ", "").replace(" && rm -rf /var/cache/apk/*", "").split(" ")
                for apk_package in apk_packages:
                    if apk_package not in dockerfile_distro["apk"]:
                        dockerfile_distro["apk"].append(apk_package)
            elif line.startswith("RUN pip "):
                pip_packages = line.replace("RUN pip install ", "").replace("pip install --upgrade setuptools && ", "").split(" ")
                for pip_package in pip_packages:
                    if pip_package not in dockerfile_distro["pip"]:
                        dockerfile_distro["pip"].append(pip_package)
            elif line.startswith("COPY "):
                if line not in dockerfile_distro["copy"]:
                    dockerfile_distro["copy"].append(line)
            else:
                dockerfile_distro["others"].append(line)
        # read .gitignore file
        gitignore_file = package_tmp_dir+"/.gitignore"
        if os.path.exists(gitignore_file): 
            try:
                with open(gitignore_file) as f: content = f.read()
            except Exception,e:
                print_error("Unable to load .gitignore of "+package_name+": "+str(e))
            content = content.replace("\r\n", "\n")
            # parse the file
            for line in content.split("\n"):
                if line == "" or line[0] == "#": continue
                # if the same line skip it
                if line in gitignore_distro: continue
                gitignore_distro.append(line)
        # read .dockerignore file
        dockerignore_file = package_tmp_dir+"/.dockerignore"
        if os.path.exists(dockerignore_file): 
            try:
                with open(dockerignore_file) as f: content = f.read()
            except Exception,e:
                print_error("Unable to load .dockerignore of "+package_name+": "+str(e))
            content = content.replace("\r\n", "\n")
            # parse the file
            for line in content.split("\n"):
                if line == "" or line[0] == "#": continue
                # if the same line skip it
                if line in dockerignore_distro: continue
                dockerignore_distro.append(line)
        # move all the files of the downloaded packages in the build directory
        for (current_path, dirnames, filenames) in os.walk(package_tmp_dir): 
            for filename in filenames:
                package_tmp_file = current_path+os.sep+filename
                build_file = package_tmp_file.replace(package_tmp_dir, build_dir, 1)
                build_parent_dir = build_file.replace(filename, "", 1)
                if not os.path.exists(build_parent_dir): 
                    os.makedirs(build_parent_dir)
                run("mv -f "+package_tmp_file+" "+build_file)
    # build and save the distro Dockerfile
    try: 
        f = open(build_dir+"/Dockerfile", "w")
        for arg in dockerfile_distro["arg"]:
            f.write(arg+"\n")
        f.write(dockerfile_distro["from"]+"\n")
        if len(dockerfile_distro["apt-get"]) > 0:
            f.write("RUN apt-get update && apt-get install -y "+" ".join(dockerfile_distro["apt-get"])+" && apt-get clean && rm -rf /var/lib/apt/lists/*\n")
        if len(dockerfile_distro["apk"]) > 0:
            f.write("RUN apk update && apk add "+" ".join(dockerfile_distro["apk"])+" && rm -rf /var/cache/apk/*\n")
        if len(dockerfile_distro["pip"]) > 0:
            f.write("RUN pip install --upgrade setuptools && pip install "+" ".join(dockerfile_distro["pip"])+"\n")
        for line in dockerfile_distro["others"]:
            f.write(line+"\n")
        for line in dockerfile_distro["copy"]:
            f.write(line+"\n")
        f.close()
    except Exception,e:
        print_error("Unable to save distro Dockerfile: "+str(e))
    # build and save .gitignore
    if len(gitignore_distro) > 0:
        try: 
            f = open(build_dir+"/.gitignore", "w")
            for line in gitignore_distro:
                f.write(line+"\n")
            f.write(tmp_dir.replace(MY_DIRECTORY+"/", "", 1)+"\n")
            f.write(build_dir.replace(MY_DIRECTORY+"/", "", 1)+"\n")
            f.close()
        except Exception,e:
            print_error("Unable to save distro .gitignore: "+str(e))
    # build and save .dockerignore
    if len(dockerignore_distro) > 0:
        try: 
            f = open(build_dir+"/.dockerignore", "w")
            for line in dockerignore_distro:
                f.write(line+"\n")
            f.write(tmp_dir.replace(MY_DIRECTORY+"/", "", 1)+"\n")
            f.write(build_dir.replace(MY_DIRECTORY+"/", "", 1)+"\n")
            f.write(tmp_dir.replace(MY_DIRECTORY+"/", "", 1)+"/\n")
            f.write(build_dir.replace(MY_DIRECTORY+"/", "", 1)+"/\n")
            f.close()
        except Exception,e:
            print_error("Unable to save distro .gitignore: "+str(e))
    # keep track of the old revision number in the manifest file
    if old_manifest is not None:
        manifest_distro["revision"] = old_manifest["revision"]
    # build and save the distro manifest file
    try: 
        f = open(build_dir+"/manifest.yml", "w")
        f.write(yaml.safe_dump(manifest_distro, default_flow_style=False))
        f.close()
    except Exception,e:
        print_error("Unable to save distro manifest file: "+str(e))
    # for each file of the build directory check if needs to be moved into the main directory
    created = 0
    updated = 0
    deleted = 0
    for (current_path, dirnames, filenames) in os.walk(build_dir): 
        for filename in filenames:
            build_file = current_path+os.sep+filename
            target_file = build_file.replace(build_dir, MY_DIRECTORY, 1)
            target_dir = target_file.replace(filename, "", 1)
            # if this is a new or updated file, overwrite it
            if not os.path.exists(target_file):
                print_debug("Creating "+target_file)
                if not os.path.exists(target_dir): 
                    os.makedirs(target_dir)
                run("cp -f "+build_file+" "+target_file)            
                created = created+1
            elif not filecmp.cmp(build_file, target_file):
                print_debug("Updating "+target_file)
                if not os.path.exists(target_dir): 
                    os.makedirs(target_dir)
                run("cp -f "+build_file+" "+target_file)            
                updated = updated+1
    # for each file of the main directory check if exists in the build directory, otherwise, delete it
    for (current_path, dirnames, filenames) in os.walk(MY_DIRECTORY): 
        for filename in filenames:
            if current_path.startswith(distro_dir) or current_path.startswith(MY_DIRECTORY+"/.git"): continue
            target_file = current_path+os.sep+filename
            build_file = target_file.replace(MY_DIRECTORY, build_dir, 1)
            # if the file does not exist anymore, delete it
            if not os.path.exists(build_file):
                print_debug("Deleting "+target_file)
                deleted = deleted+1
                if os.path.isdir(target_file):
                    run("rm -rf "+target_file)
                else:
                    run("rm -f "+target_file)
                    # if there are no more files in the directory, delete it
                    if len([name for name in os.listdir(current_path) if os.path.isfile(os.path.join(current_path, name))]) == 0:
                        run("rmdir "+current_path)
    print_output("Done. "+str(created)+" files created, "+str(updated)+" files updated, "+str(deleted)+" files deleted")
    # clean up
    run("rm -rf "+tmp_dir)
    run("rm -rf "+build_dir)
    
## MAIN - GENERAL ##

# upgrade egeoffrey-cli to the latest version
elif command == "upgrade":
    # upgrade needed
    version = requires_upgrade()
    if version is not None:
        # download the latest version
        try:
            response = requests.get(MY_DOWNLOAD_URL+"?timestamp="+str(int(time.time())))
            if response.status_code != 200: print_error("Unable to download the newest version of egeoffrey-cli")
        except Exception,e:
            print_error("Unable to download the newest version of egeoffrey-cli: "+str(e))
        # replace this file
        try:
            f = open("/usr/local/bin/egeoffrey-cli", "w")
            f.write(response.content)
            f.close()
        except Exception,e:
            print_error("Unable to install the latest version: "+str(e))
        print_output("Upgrade to version v"+version+" ("+str(BRANCH)+") successful")
    else:
        print_output("Already at the latest version - v"+str(VERSION)+"-"+str(REVISION)+" ("+str(BRANCH)+")")

# print out this script version
elif command == "version":
    print_output("egeoffrey-cli v"+str(VERSION)+"-"+str(REVISION)+" ("+str(BRANCH)+")")

else:
    print_usage()

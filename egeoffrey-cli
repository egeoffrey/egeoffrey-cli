#!/usr/bin/python

import sys
import os
import re
import time
import json
import yaml
import subprocess
import requests

## constants
BRANCH = "development"
VERSION = 1.0
REVISION = 15
MARKETPLACE_URL = "https://api.github.com/repos/egeoffrey/egeoffrey-marketplace/contents/marketplace"
MARKETPLACE_BRANCH = "master"
SDK_BRANCH = "development"
MY_MANIFEST_URL = "https://raw.githubusercontent.com/egeoffrey/egeoffrey-cli/"+BRANCH+"/version.yml"
MY_DOWNLOAD_URL = "https://raw.githubusercontent.com/egeoffrey/egeoffrey-cli/"+BRANCH+"/egeoffrey-cli"
MY_DIRECTORY = os.getcwd()
DOCKER_COMPOSE = "docker-compose.yml"
SUPPORTED_MANIFEST_SCHEMA = 2

## variables
# debug output 
debug = False
# do not require user interaction
quite = False
# do not push anything out
offline = False
# requested command
command = ""
# arguments to the requested command
arguments = ""
# docker-compose .env 
env = {}
# docker-compose configuration
config = {}

# print out an error message and exit
def print_error(message):
    print "\033[91mERROR\033[0m: "+str(message)
    exit(1)
    
# print out a warning message
def print_warning(message):
    print "\033[33mWARNING\033[0m: "+str(message)
    
# print out a debug message
def print_debug(message):
    global debug
    if debug: print message

# print out a message    
def print_output(message):
    print message
    
# parse command line arguments
def parse_command_line():
    global command, arguments, debug, quite, offline, MY_DIRECTORY, DOCKER_COMPOSE
    skip_next = False
    for i in range(1, len(sys.argv)):
        if skip_next: 
            skip_next = False
            continue
        arg = sys.argv[i]
        arg = re.sub(' +',' ', arg)
        if arg == "-d":
            MY_DIRECTORY = sys.argv[i+1]
            skip_next = True
            continue
        if arg == "-f":
            DOCKER_COMPOSE = sys.argv[i+1]
            skip_next = True
            continue
        if arg == "-v":
            debug = True
            continue
        if arg == "-o":
            offline = True
            continue
        if arg == "-q":
            quite = True
            continue
        if command == "":
            command = arg
            continue
        arguments = arguments+" "+arg
    arguments = arguments.strip()
    print_debug("Base directory: "+MY_DIRECTORY)
    print_debug("Command: "+command)
    print_debug("Arguments: "+arguments)
    
# check if the cli requires to be upgraded
def requires_upgrade():
    # download the manifest from github which contains the latest version number
    print_debug("Downloading egeoffrey-cli manifest from "+MY_MANIFEST_URL)
    try:
        response = requests.get(MY_MANIFEST_URL+"?timestamp="+str(int(time.time())))
        if response.status_code != 200: print_error("Unable to download egeoffrey-cli manifest")
        manifest =  yaml.load(response.content, Loader=yaml.SafeLoader)
    except Exception,e:
        print_error("Unable to download egeoffrey-cli manifest: "+str(e))
    # check if we are at the latest version
    print_debug("egeoffrey-cli latest release v"+str(manifest["revision"])+", currently running v"+str(REVISION))
    if manifest["version"] > VERSION or (manifest["version"] == VERSION and manifest["revision"] > REVISION): return str(manifest["version"])+"-"+str(manifest["revision"])
    return None
    
# load .env file with common docker-compose environment variables
def load_env():
    global env
    env_file = MY_DIRECTORY+"/.env"
    if not os.path.isfile(env_file):
        print_error("the configuration file '.env' cannot be found in "+env_file+". Please switch into eGeoffrey installation directory or provide the directory with the -d option")
    try:
        with open(env_file) as f: content = f.read()
        for line in content.split("\n"):
            # clean up the file
            line = re.sub(' +',' ', line).replace('"', "")
            if line.startswith("#"): continue
            if "=" not in line: continue
            split = line.split("=")
            # store it into the env variable
            env[split[0]] = split[1]
    except Exception,e: 
        print_error("unable to read environment file from "+env_file+": "+str(e))
    print_debug("Loaded "+str(len(env))+" env settings")

# download and return a manifest from a remote git repository
def get_manifest(package, repository, branch):
    print_debug("Loading manifest file for package "+package+":"+branch)
    try:
        manifest_url = "https://raw.githubusercontent.com/"+repository+"/"+branch+"/manifest.yml?timestamp="+str(int(time.time()))
        response = requests.get(manifest_url)
        if response.status_code != 200: 
            print_warning("skipping package "+package+":"+branch)
            return None
        return yaml.load(response.content, Loader=yaml.SafeLoader)
    except Exception,e:
        print_warning("skipping package "+package+":"+branch+": "+str(e))
        return None    

# return an array of registered packages in the marketplace
def list_marketplace():
    index = []
    print_debug("Listing Marketplace items...")
    try:
        # list all files in the marketplace database
        response = requests.get(MARKETPLACE_URL+"?ref="+MARKETPLACE_BRANCH)
        if response.status_code != 200: print_error("Unable to list marketplace items")
        content = json.loads(response.content)
        # for each package in the marketplace
        for entry in content:
            if "path" not in entry or "name" not in entry: continue
            index.append(entry["name"].replace(".yml", ""))
        print_debug("Marketplace has "+str(len(content))+" entries")
        return index
    except Exception,e:
        print_error("Unable to list marketplace items: "+str(e))

# return the github repo of a marketplace package 
def get_repository(package):
    try: 
        # download from the marketplace the file for the package
        response = requests.get("https://raw.githubusercontent.com/egeoffrey/egeoffrey-marketplace/"+MARKETPLACE_BRANCH+"/marketplace/"+package+".yml?timestamp="+str(int(time.time())))
        if response.status_code != 200: print_error("Unable to retrieve github repository for package "+package)
        content = yaml.load(response.content, Loader=yaml.SafeLoader)
        if "github" not in content: return None
        return content["github"]
    except Exception,e:
        print_error("Unable to retrieve github repository for package "+package+": "+str(e))
        
# parse a package splitting the package name from the branch
def parse_package(string):
    package = string
    branch = "master"
    if ":" in string: package, branch = string.split(":", 1)
    return package, branch        
    
# build the marketplace database
def get_marketplace(requested_packages=None, package_branch="master"):
    global env
    marketplace = {}
    # get the list of all items in the marketplace
    marketplace_index = list_marketplace()
    try:
        # for each package in the marketplace
        for i in range(0, len(marketplace_index)):
            marketplace_package = marketplace_index[i]
            # no specific package requested, tell the user we need to download the entire marketplace
            if requested_packages is None:
                msg = "Downloading marketplace database: "+str( (i+1)*100/len(marketplace_index) )+"%"
                sys.stdout.write('\r')
                sys.stdout.write(msg)
                sys.stdout.flush()
                if i == len(marketplace_index)-1: sys.stdout.write('\n')
            # if specific packages are requested, filter out unwanted packages
            if requested_packages is not None:
                include_package = False
                for package in requested_packages:
                    package_name, package_branch = parse_package(package)
                    if package_name == marketplace_package: include_package = True
                if not include_package: continue
            # download the marketplace item which contains the github repo reference
            repository = get_repository(marketplace_package)
            if repository is None: continue
            # download the manifest from the remote repository
            manifest = get_manifest(marketplace_package, repository, package_branch)
            if manifest is None: continue
            if manifest["manifest_schema"] != SUPPORTED_MANIFEST_SCHEMA:
                print_warning("Skipping package "+marketplace_package+" because manifest v"+str(manifest["manifest_schema"])+" is not supported")
                continue
            # populate the marketplace
            marketplace[marketplace_package] = manifest
        return marketplace
    except Exception,e:
        print_error("Unable to build marketplace index: "+str(e))
        
# load docker-compose configuration
def load_configuration():
    global config
    docker_compose_file = MY_DIRECTORY+"/"+DOCKER_COMPOSE
    # load docker-compose common variables
    load_env()
    # if docker-compose file does not exist, make an empty version
    if not os.path.isfile(docker_compose_file): 
        config = {
            "version": "3",
            "services": {},
            "networks": {
                "egeoffrey": {
                    "driver": "bridge"
                }
            }
        }
    else:
        print_debug("Loading docker-compose configuration from "+docker_compose_file)
        try:
            with open(docker_compose_file) as f: content = f.read()
            config = yaml.load(content, Loader=yaml.SafeLoader)
        except Exception,e:
            print_error("Unable to load eGeoffrey docker configuration: "+str(e))
        
# save docker-compose configuration
def save_configuration():
    global config
    docker_compose_file = MY_DIRECTORY+"/"+DOCKER_COMPOSE
    print_debug("Saving docker-compose configuration to "+docker_compose_file)
    try: 
        f = open(docker_compose_file, "w")
        f.write(yaml.safe_dump(config, default_flow_style=False))
        f.close()
    except Exception,e:
        print_error("Unable to save eGeoffrey docker configuration: "+str(e))
       
# run docker-compose
def run_docker_compose(args):
    current_dir = os.getcwd()
    # when docker-compose runs in a container cannot mount the target directory, let's chdir into it first
    os.chdir(MY_DIRECTORY)
    docker_compose_file = MY_DIRECTORY+"/"+DOCKER_COMPOSE
    subprocess.call(["docker-compose", "-f", docker_compose_file] + args)
    # get back to the original directory
    os.chdir(current_dir)
    
# run docker
def run_docker(args):
    subprocess.call(["docker"] + args)

# run git
def run_git(args):
    return subprocess.check_output(["git", "-C", MY_DIRECTORY] + args)
    
# read and return a (local) manifest file
def read_manifest(manifest_file):
    if not os.path.isfile(manifest_file):
        print_error("Unable to find a manifest file in "+MY_DIRECTORY)
    try:
        with open(manifest_file) as f: content = f.read()
        manifest = yaml.load(content, Loader=yaml.SafeLoader)
    except Exception,e:
        print_error("Invalid manifest file in "+MY_DIRECTORY+": "+str(e))
    if manifest["manifest_schema"] != SUPPORTED_MANIFEST_SCHEMA:
        print_error("manifest v"+str(manifest["manifest_schema"])+" is not supported")
    return manifest
    
# print usage
def print_usage():
    print_output("egeoffrey-cli v"+str(VERSION)+"-"+str(REVISION)+" ("+str(BRANCH)+")")
    print_output("Usage: egeoffrey-cli [OPTIONS] COMMAND ARGUMENTS")
    print_output("")
    print_output("Options:")
    print_output("  -d <directory>                      set the working directory")
    print_output("  -f <filename>                       set custom docker-compose.yml filename")
    print_output("  -v                                  enable debug output")
    print_output("  -q                                  quite mode - do not run interactively")
    print_output("  -o                                  offline mode")
    print_output("")
    print_output("General commands:")
    print_output("  upgrade                             Upgrade egeoffrey-cli to the latest version")
    print_output("  version                             Print out this script version")
    print_output("")
    print_output("Run commands:")
    print_output("  info <package>                      Print out information on a given package")
    print_output("  install <package(s)>                Install the provided package(s)")
    print_output("  list_available [<branch>]           List available packages that can be installed")
    print_output("  list_installed                      List already installed packages")
    print_output("  logs [-f] [<package(s)>]            Print out log information")
    print_output("  reload                              Reload the configuration")
    print_output("  search <string>                     Search packages matching the provided description")
    print_output("  start [<package(s)>]                Start configured services")
    print_output("  stats                               Print out running packages CPU and memory utilization")
    print_output("  status                              Show currently running components")
    print_output("  stop                                Stop running services")
    print_output("  update [<package(s)>]               Update the installed package(s)")
    print_output("  uninstall [<package(s)>]            Uninstall the provided package(s)")
    print_output("")
    print_output("Build commands:")
    print_output("  commit '<description>'              Commit changes to the local and remote git repository")
    print_output("  build <amd64,arm>                   Build a docker image and push it upstream")
    print_output("  build_sdk <image> <amd64,arm>       Build a SDK docker image and push it upstream")

        
## MAIN - RUN ##

# parse provided command line
parse_command_line()
# check if running the latest version
if not offline:
    version = requires_upgrade()
    if version is not None: print_warning("a new version of egeoffrey-cli is available ("+version+"), run 'egeoffrey-cli upgrade' to upgrade")

# do what requested by the user

# print out information on a given package
if command == "info":
    package = arguments
    if package == "": print_error("a package name must be provided")
    marketplace = get_marketplace([package])
    package_name, package_branch = parse_package(package)
    if package_name not in marketplace: print_error("package "+package+" not found")
    manifest = marketplace[package_name]
    print_output("Package: "+manifest["package"])
    print_output("Tags: "+manifest["tags"])
    print_output("Version: "+str(manifest["version"])+"-"+str(manifest["revision"])+" ("+str(manifest["branch"])+")")
    print_output("Github: https://github.com/"+manifest["github"])
    print_output("Docker: "+manifest["dockerhub"])
    modules = []
    for module_object in manifest["modules"]:
        for module in module_object:
            modules.append(module)
    print_output("Modules: "+", ".join(modules))
    print_output("")
    print_output(manifest["description"])
    print_output("")
    
# install a package
elif command == "install":
    load_configuration()
    packages = arguments.split(" ")
    if len(packages) == 0: print_error("at least a package name must be provided")
    marketplace = get_marketplace(packages)
    for package in packages:
        package_name, package_branch = parse_package(package)
        # ensure package is not already installed
        if package_name in config["services"]:
            print_output(package_name+" is already installed")
            continue
        # ensure package exists in the marketplace
        if package_name not in marketplace:
            print_output(package_name+" not found in the marketplace, skipping")
            continue
        # add the package to the docker-compose file
        try:
            service = {}
            manifest =  marketplace[package_name]
            print_debug("Installing package "+package_name+":"+package_branch)
            # if runtime parameters are provided, merge them with the service
            if "container_config" in manifest: 
                print_debug("Container default runtime: "+str(manifest["container_config"]))
                service.update(manifest["container_config"])
            # add env_file
            service["env_file"] = ".env"
            # add image
            service["image"] = manifest["dockerhub"]+":"+package_branch+"-"+env["ARCHITECTURE"]
            # add EGEOFFREY_MODULES variable
            if "modules" in manifest:
                modules = []
                for module_object in manifest["modules"]:
                    for module in module_object:
                        modules.append(module)
                if len(modules) > 0:
                    if "environment" not in service: service["environment"] = []
                    service["environment"].append("EGEOFFREY_MODULES="+", ".join(modules))
            # link to the default bridge network if no other instructions are provided
            if "network_mode" not in service and "networks" not in service:
                service["networks"] = []
                service["networks"].append("egeoffrey")
            # if there is a volume mapping, create the local MY_DIRECTORY
            if "volumes" in service:
                for volume in service["volumes"]:
                    volume = volume.replace('"', "")
                    split = volume.split(":")
                    directory = split[0]
                    if not os.path.exists(directory):
                        print_debug("Creating directory "+directory)
                        os.makedirs(directory)
            if "devices" in service:
                for device in service["devices"]:
                    device = device.replace('"', "")
                    split = device.split(":")
                    print_output("Please ensure the mapped device "+split[0]+" exists")
            # the docker daemon will restart the service at boot time
            # TODO: add restart = always
            #service["restart"] = "always"
            # add the new service
            config["services"][package_name] = service
        except Exception,e:
            print_error("installation of package "+package_name+":"+package_branch+" failed: "+str(e))
        print_output(package_name+":"+package_branch+" installed successfully")
    # save the updated configuration file
    save_configuration()
    
# list packages available to install
elif command == "list_available":
    load_configuration()
    branch = arguments if arguments != "" else "master"
    marketplace = get_marketplace(None, branch)
    for package in sorted(marketplace):
        # skip already installed packages
        if package in config["services"]: continue
        print_output(package+": "+marketplace[package]["description"])

# list packages already installed
elif command == "list_installed":
    load_configuration()
    for service in sorted(config["services"]):
        print_output(service)
        
# run docker logs
elif command == "logs":
    options = arguments.split(" ") if arguments != "" else []
    run_docker_compose(["logs"]+options)
    
# reload the configuration
elif command == "reload":
    run_docker_compose(["up", "-d", "--remove-orphans"])

# search for a package
elif command == "search":
    load_configuration()
    branch = arguments if arguments != "" else "master"
    marketplace = get_marketplace(None, branch)
    for package in sorted(marketplace):
        if arguments in marketplace[package]["description"] or arguments in marketplace[package]["tags"]:
            print_output(package+": "+marketplace[package]["description"])
            
# start services
elif command == "start":
    packages = arguments.split(" ") if arguments != "" else []
    run_docker_compose(["up", "-d", "--remove-orphans"]+packages)
    
# run docker stats
elif command == "stats":
    run_docker(["stats", "--no-stream"])

# run docker ps
elif command == "status":
    run_docker_compose(["ps"])

# stop services
elif command == "stop":
    run_docker_compose(["down"])
    
# update an installed packages
elif command == "update":
    packages = arguments.split(" ") if arguments != "" else []
    run_docker_compose(["pull"]+packages)
    
# uninstall a package
elif command == "uninstall":
    load_configuration()
    packages = arguments.split(" ")
    if len(packages) == 0: print_error("at least a package name must be provided")
    for package in packages:
        package_name, package_branch = parse_package(package)
        # ensure package is installed
        if package_name not in config["services"]:
            print_output(package_name+" is not installed")
            continue
        # remove the package from the docker-compose file
        del config["services"][package_name]
        print_output(package_name+" uninstalled successfully")
    # save the updated configuration file
    save_configuration()
    
## MAIN - BUILD ##

# commit changes to a git repository and push upstream
elif command == "commit":
    if arguments == "": print_error("provide a description for this commit")
    # read the manifest file
    manifest_file = MY_DIRECTORY+"/manifest.yml"
    manifest = read_manifest(manifest_file)
    # ensure we are in the same branch of the manifest
    output = run_git(["branch"])
    branch = None
    for line in output.split("\n"):
        if line.startswith("* "): branch = line.replace("* ","")
    if branch is None: print_error("unable to determine current branch of "+MY_DIRECTORY)
    if branch != manifest["branch"]: print_error(MY_DIRECTORY+" current branch does not match with the manifest's branch")
    if "nothing to commit" not in run_git(["status"]):
        # ask the user before proceeding
        if not quite:
            # add the new files to git
            print_output(run_git(["add", "."]))
            print_output(run_git(["status"]))
            raw_input("Do you want to proceed committing these changes?")
        # increase revision number
        manifest["revision"] = manifest["revision"]+1
        # convert the manifest back to YAML
        try:
            content = yaml.safe_dump(manifest, default_flow_style=False)
        except Exception,e:
            print_error("unable to edit the manifest file: "+str(e))
        # save the updated manifest
        try:
            f = open(manifest_file, "w")
            f.write(content)
            f.close()
        except Exception,e:
            print_error("unable to write the manifest file: "+str(e))
        print_output("Setting new version for "+manifest["package"]+" to "+str(manifest["version"])+"-"+str(manifest["revision"])+" ("+str(manifest["branch"])+")")
        # add the new files to git 
        print_output(run_git(["add", "."]))
        # print out the status
        print_output(run_git(["status"]))
        print_output("\nPublishing changes to the remote repository...")
        # commit the changes
        print_output(run_git(["commit", "-m", arguments]))
        if not offline:
            # push the changes to the remote repository
            print_output(run_git(["push", "origin", manifest["branch"]]))
            # TODO: for master branch, tag with version number
    else:
        print_output("Nothing to commit on "+manifest["package"])

# build a docker image and push upstream
elif command == "build":    
    if arguments == "": print_error("provide an architecture or a set of architectures to build against (e.g. amd64, arm)")
    architectures = arguments.split(",")
    # read the manifest file
    manifest = read_manifest(MY_DIRECTORY+"/manifest.yml")
    # for each architecture
    for architecture in architectures:
        if architecture not in ["amd64", "arm"]: print_error("Invalid architecture "+architecture)
        if architecture == "arm": architecture = "arm32v6"
        # build the docker image
        image = manifest["dockerhub"]+":"+manifest["branch"]+"-"+architecture
        print_output("\nBuilding docker image "+image+"...")
        run_docker(["build", "--rm", "--build-arg", "SDK_VERSION="+SDK_BRANCH, "--build-arg", "ARCHITECTURE="+architecture, "--tag", image, MY_DIRECTORY])
        if not offline:
            # push the image to dockerhub
            print_output("\nPublishing docker image "+image+"...")
            run_docker(["push", image])
            # TODO: for master branch, tag with version number
        
# build a docker image and push upstream
elif command == "build_sdk":
    arguments = arguments.split(" ")
    if len(arguments) != 2: print_error("provide a SDK image and architecture(s) to build against")
    sdk_image = arguments[0]
    architectures = arguments[1].split(",")
    # read the manifest file
    manifest = read_manifest(MY_DIRECTORY+"/sdk/manifest.yml")
    # for each architecture
    for architecture in architectures:
        if architecture not in ["amd64", "arm"]: print_error("Invalid architecture "+architecture)
        if architecture == "arm" : architecture = "arm32v6"
        # build the docker image
        image = manifest["dockerhub"]+"-"+sdk_image+":"+manifest["branch"]+"-"+architecture
        print_output("\nBuilding docker image "+image+"...")
        run_docker(["build", "--rm", "--file", MY_DIRECTORY+"/Dockerfile-"+sdk_image, "--build-arg", "ARCHITECTURE="+architecture, "--tag", image, MY_DIRECTORY])
        if not offline:
            # push the image to dockerhub
            print_output("\nPublishing docker image "+image+"...")
            run_docker(["push", image])
    
## MAIN - GENERAL ##

# upgrade egeoffrey-cli to the latest version
elif command == "upgrade":
    # upgrade needed
    version = requires_upgrade()
    if version is not None:
        # download the latest version
        try:
            response = requests.get(MY_DOWNLOAD_URL+"?timestamp="+str(int(time.time())))
            if response.status_code != 200: print_error("Unable to download the newest version of egeoffrey-cli")
        except Exception,e:
            print_error("Unable to download the newest version of egeoffrey-cli: "+str(e))
        # replace this file
        try:
            f = open("/usr/local/bin/egeoffrey-cli", "w")
            f.write(response.content)
            f.close()
        except Exception,e:
            print_error("Unable to install the latest version: "+str(e))
        print_output("Upgrade to version v"+version+" ("+str(BRANCH)+") successful")
    else:
        print_output("Already at the latest version - v"+str(VERSION)+"-"+str(REVISION)+" ("+str(BRANCH)+")")

# print out this script version
elif command == "version":
    print_output("egeoffrey-cli v"+str(VERSION)+"-"+str(REVISION)+" ("+str(BRANCH)+")")

else:
    print_usage()
